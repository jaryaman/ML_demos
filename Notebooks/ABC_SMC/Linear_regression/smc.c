/*
Performing approximate Bayesian computation sequential Monte Carlo (Toni et al.
2009) for linear regression.

Synthetic data is generated by `ground_truth_and_analysis.ipynb`.

This script writes particles.csv, where each row corresponds to a particle and
each column corresponds to a round of SMC.

Defining #DEBUG_MODE will silence all writing to stdout. One may then add
printf statements in the code, and perhaps write the output to file as:
`./run.sh > output.txt`

Parameter ordering convention:
0 - gradient
1 - intercept
2 - standard deviation

Author: Juvid Aryaman
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_sort_double.h>
#include <gsl/gsl_statistics.h>
#include <gsl/gsl_fit.h>


#define N_DATA 30
#define N_PARAMETERS 3

#define N_PARTICLES 20000

#define RND gsl_rng_uniform(r)
#define SEED 1

#define X_DATA_FILENAME "x.csv"
#define Y_DATA_FILENAME "y.csv"

// Global variables
/*Define the distance threshold for every round of SMC*/
double distance_threshold_schedule[] = {7.0, 6.375, 5.75, 5.125, 4.5, 3.875,
	3.25, 2.625, 2.0};
int N_ROUNDS_SMC = (int)(sizeof(distance_threshold_schedule) / sizeof(double));


#include "smc.h"
#include "lin_reg.h"

//#define DEBUG_MODE

int main(int argc, char *argv[]) {

#ifndef DEBUG_MODE
	printf("Threshold schedule:\n");
	print_double_array(distance_threshold_schedule, N_ROUNDS_SMC);
	printf("\n");
#endif

/* set up GSL RNG */
gsl_rng *r = gsl_rng_alloc(gsl_rng_mt19937);
/* end of GSL setup */

gsl_rng_set(r, SEED);

/////////////////////////
/*Read data*/
/////////////////////////

FILE *data_pointer_x, *data_pointer_y;

data_pointer_x = fopen(X_DATA_FILENAME, "r");
data_pointer_y = fopen(Y_DATA_FILENAME, "r");

double data_x[N_DATA];
double data_y[N_DATA];
int i, j, read_error_status_x, read_error_status_y;
for (i=0; i < N_DATA; i++){
	read_error_status_x = fscanf(data_pointer_x, "%lf\n", &data_x[i]);
	read_error_status_y = fscanf(data_pointer_y, "%lf\n", &data_y[i]);
}
if (read_error_status_x != 1){printf("Error reading X data\n"); return 0;}
if (read_error_status_y != 1){printf("Error reading Y data\n"); return 0;}

/////////////////////////
/*Initialise variables*/
/////////////////////////

/*Fit a linear model to the data, which will be used as summary statistics of
the data*/
double gradient_fit_data, intercept_fit_data, sigma_fit_data, cov00, cov01, cov11, sumsq;
int gsl_fit_return_value;
gsl_fit_return_value = gsl_fit_linear(data_x, 1, data_y, 1, N_DATA,
																			&intercept_fit_data, &gradient_fit_data,
																			&cov00, &cov01, &cov11, &sumsq);
if (gsl_fit_return_value != 0) {printf("Fit failed.\n"); return -1;}
sigma_fit_data = sqrt(sumsq/(N_DATA-2));

#ifndef DEBUG_MODE
	printf("gradient ML = %.8f\n", gradient_fit_data);
	printf("intercept ML = %.8f\n", intercept_fit_data);
	printf("sigma ML = %.8f\n", sigma_fit_data);
#endif



/*Make a (N_PARAMETERS X N_ROUNDS_SMC X N_PARTICLES) array to store all
particles at all rounds of SMC*/
double*** theta_particle;
theta_particle = (double***) malloc(N_PARAMETERS * sizeof(double**));
for (i = 0; i < N_PARAMETERS; i++){
	theta_particle[i] = (double**) malloc(N_ROUNDS_SMC * sizeof(double*));
}
for (i = 0; i < N_PARAMETERS; i++){
	for (j = 0; j < N_ROUNDS_SMC; j++){
		theta_particle[i][j] = (double*) malloc(N_PARTICLES * sizeof(double));
	}
}

double *simulated_data = (double*) malloc(N_DATA * sizeof(double));
double *distance = malloc(N_PARTICLES * sizeof(double));
double **weight;
weight = (double**) malloc(N_ROUNDS_SMC * sizeof(double*));
for (i = 0; i < N_ROUNDS_SMC; i++) {
	weight[i] = (double*) malloc(N_PARTICLES * sizeof(double));
}


double weight_normalizer = 0.0;

int time_smc=0; // an index of each round of SMC
int param_index_chosen, prior_violated;
int particle_index;
/////////////////////////
/*Perform ABC SMC*/
/////////////////////////

/*For every round of SMC*/
for (time_smc = 0; time_smc < N_ROUNDS_SMC; time_smc++) {
	#ifndef DEBUG_MODE
		printf("Round %d of SMC\n", time_smc);
	#endif

	/*Draw or perturb a particle and compute distance*/
	for (particle_index = 0; particle_index < N_PARTICLES; particle_index++) {
		// reset distance of particle
		distance[particle_index] = distance_threshold_schedule[time_smc] + 1.0;

		while (distance[particle_index] > distance_threshold_schedule[time_smc]) {
			if (time_smc == 0) {
				// Sample from the prior
				sample_prior(r, theta_particle, particle_index);
			}
			else{
				/*Sample from the old weights*/
				param_index_chosen = weighted_choice(r, weight[time_smc-1]);
				if ((param_index_chosen < 0)||(param_index_chosen >= N_PARTICLES)) {
					printf("Error in param_index_chosen\n");
					printf("time_smc = %d\n", time_smc);
					return -1;
				}

				perturb_particle(r, theta_particle, time_smc, param_index_chosen,
												 particle_index);

				// Check if prior support is 0
				prior_violated = check_prior_violated(theta_particle, time_smc,
																							particle_index);
				if(prior_violated == 1) continue;
			}

			simulate_dataset(r, theta_particle, data_x, simulated_data, time_smc,
											 particle_index);

			distance[particle_index] = distance_metric_sum_abs_res(simulated_data, data_y);
		}
	}

	#ifndef DEBUG_MODE
		printf("Particles sampled.\n");
	#endif



	/*Compute & Normalise weights. For uniform priors, and a uniform perturbation
	kernel, all surviving particles are weighted identically as 1/N_PARTICLES.
	Whilst seemingly inefficient, I keep this code here for clarity/generality.
	The bottleneck in computation time is the while loop above.*/
	if (time_smc==0){ for (i = 0; i < N_PARTICLES; i++) weight[0][i] = 1.0;}
	else{
		weight_normalizer = 0.0;
		for (particle_index = 0; particle_index < N_PARTICLES; particle_index++) {
			// kernel_pdf is uniform, so is independent of the parameters
			weight_normalizer +=  weight[time_smc-1][particle_index]*kernel_pdf();
		}
		for (particle_index = 0; particle_index < N_PARTICLES; particle_index++) {
			weight[time_smc][particle_index] = prior_pdf(theta_particle, time_smc,
																				 particle_index)/weight_normalizer;
		}
	}
	weight_normalizer = 0.0;
	for (i = 0; i < N_PARTICLES; i++)	weight_normalizer += weight[time_smc][i];
	for (i = 0; i < N_PARTICLES; i++){
		weight[time_smc][i] = weight[time_smc][i]/weight_normalizer;
	}


}

#ifndef DEBUG_MODE
	printf("Writing particles to file\n");
#endif
	write_particles_to_csv(theta_particle);

char weight_filename[] = "weights.csv";
write_2d_double_array_to_csv(weight, N_ROUNDS_SMC, N_PARTICLES, weight_filename);

#ifndef DEBUG_MODE
	printf("Done!\n");
#endif

return 0; //return from main
} //close main
